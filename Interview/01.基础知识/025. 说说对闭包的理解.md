## 说说对闭包的理解

当函数可以记住并访问所在的词法作用域时，就产生了**闭包**，即使函数是在当前词法作用域之外执行的。

```javascript
function foo() {
    var a = 1; // a 是一个被 foo 创建的局部变量
    function bar() { // bar 是一个内部函数，是一个闭包
        console.log(a); // 使用了父函数中声明的变量
    }
    return bar();
}
const myFoo = foo();
myFoo(); // 1
```

用一句话描述：**闭包是指有权访问另一个函数作用域中变量的函数**。创建闭包最常见的方式就是，在一个函数内部创建另一个函数。

### 常见的闭包

```javascript
function foo(a) {
    setTimeout(function timer(){
        console.log(a)
    }, 1000)
}
foo(2);
```

`foo`执行`1000ms` 后，它的内部作用域不会消失，`timer`函数依然保有 `foo` 作用域的引用。timer函数就是一个闭包。

### 闭包和循环

```javascript
for(var i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i);
    }, i * 1000);
}
```

上面的这段代码，预期是每隔一秒，分别输出 `0, 1, 2, 3, 4`, 但实际上依次输出的是 `5, 5, 5, 5, 5`。首先解释5是从哪里来的，这个循环的终止条件是 `i` 不再 `< 5`，条件首次成立时 `i` 的值是`5`，因此，输出显示的是循环结束时 i 的最终值。

延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的都是 `setTimeout(.., 0)`,所有的回调函数依然是在循环结束后才会被执行。因此每次输出一个 5来。

**代码改进**

```javascript
for(var i = 0; i < 5; i++) {
    (function(j){
        setTimeout(() => {
            console.log(j);
        }, j * 1000);
    })(i)
}
```

这样修改之后，在每次迭代内使用 IIFE（立即执行函数）会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代内部都会含有一个具有正确值的变量可以访问。

### 闭包的使用注意事项

闭包会携带包含它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。