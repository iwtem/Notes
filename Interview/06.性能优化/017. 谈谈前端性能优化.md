## 前端性能优化

**前端性能优化**是指从用户开始访问我们的网站到整个页面完整的展现出来的过程中，通过各种优化策略和优化方法让页面加载的更快，让用户的操作响应更及时，给用户更好的使用体验。

关于用户对于网站的性能延迟的感知，其中列出了几个**关键性的指标**：

| 延迟时间         | 指标介绍                                                     |
| :--------------- | :----------------------------------------------------------- |
| 0 ~ 16ms         | 新帧更新时间，每秒渲染 60 个新帧保证动画很流畅               |
| 0 ~ 100ms        | 响应用户操作时间，在此时间窗口内用户会感觉到响应被立即执行   |
| 100 ~ 1000ms     | 加载页面或更新视图时间，在这个窗口内用户会感觉任务进展是自然的、连续的 |
| >= 1000ms (1s)   | 用户会失去对他们正在执行的任务的注意力                       |
| >= 10000ms (10s) | 用户感到沮丧并可能放弃任务，并且以后可能会也可能不会回来     |

由此可见，性能对于一个应用非常重要。

### 1. 图片资源优化

#### 1.1 图片格式介绍

- **JPEG**

  一种针对彩色照片而广泛使用的有损压缩图形格式。是一种栅格图形，常用文件扩展名为jpg，jpeg，jpe。在互联网上常被应用于存储和传输照片。不适合线条图形和文字，图标图形，因为他的压缩算法不支持这些类型的图形，并且不支持透明度。常用于色彩丰富的照片，彩色图大焦点图banner等结构不规则的图形。

- **PNG**

  便携式网络图形，是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色，以及Alpha通道等特性。他最初的设计是为了代替GIF,能够支持半透明和透明特性，最高支持24位彩色图形和8位灰度图像。不过由于是无损压缩所以文件体积太大。比较适合纯色，透明，线条绘图，图标以及颜色较少的需要半透明的图片。

- **GIF**

  位图图形文件格式，8位色重现真彩色的图像，采用LZW压缩算法进行编码。支持256色，仅支持完全透明和完全不透明，可以支持动图，不过每个像素只有8比特，不适合存储彩色图片。常用与动画和图标。

- **WEBP**

  是一种现代图像格式，可以提供无损压缩和有损压缩两种。可以同时办证一定程序上的图像质量和较小的体积，可以插入多帧，实现动画效果。支持透明度。采用8位压缩算法，无损的webp比png小26%，有损的webp比jpeg小25-34%，比gif有更好的动画。不过最多可以处理256色，不适合彩色图片。常用于图形和半透明图像。

#### 1.2 图片压缩

对于png图片来说，可以使用jdf-png-native进行压缩, 他是node-pngquant-native工具的封装包，这个工具跨平台，压缩比高，而且压缩png24也非常的好。

```javascript
const pngquant = require('jdf-png-native');
const fs = require('fs');

fs.readFile('./in.png', (err, buffer) => {
    if (err) {
        throw err;
    }
    const resBuffer = pngquant.option({}).compress(buffer);
    fs.writeFile('./out.png', resBuffer), {
        flags: 'wb'
    }, () => {})
})
```

压缩jpg可以使用jpegtran这个工具，他也是一个node工具。使用方法比较简单，直接使用命令即可。大概压缩10%的占比。

```shell
jpegtran -copy node -optimize-outfile out.jpg in.jpg
```

对于gif文件来说可以使用gifsicle工具，他是通过改变每帧比例，减小gif文件大小，同时可以使用透明来达到更小的文件体积。是一个公认的解决方案。可以去`http://www.lcdf.org/gifsicle/`中去安装。使用方式同样也是命令行方式。

```shell
gifsicle --optimize=3 --crop-transparency -o out.gif in.gif
```

这里的优化级别不要小于2，1的话代表不压缩。压缩后基本不失帧。

还有一种压缩方式是图片可以根据网络环境来展示不同尺寸和像素的图片，通过在url后缀加不同参数来实现。比如下面的地址, 430可以修改为800来获得不同体积的图片。

```
https://img.alicdn.com/imgextra/i1/2616970884/O1CN01x6HnoK1IOuj5IosXO_!!2616970884.jpg_430x430q90.jpg
```

#### 1.3 响应式图片

响应式图片是我们可以在用户不同的窗口大小还有设备像素的情况下来展示不同大小的图片，可以用以下三种方式来实现, 第一种是可以使用js来绑定事件检测窗口大小，以此来设置图片的大小。第二种方式就是css的媒体查询。

```css
@media screen and (max-width: 640) {
    my_image { width: 640px; }
}
```

第三种可以使用html5的srcset来设置，他会根据设备的像素比来自动选择需要的图片。而且不支持srcset的浏览器也可以正常展示src的属性。

```html
<img 
  srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x" 
  src="img-960w.jpg" 
  alt="img" 
/>
```

#### 1.4 逐步加载图片的方式

其实就是延迟加载，在真实的图片加载出来之前，可以使用一张公共的图片，一般是公司的logo，先将布局撑起来，然后再换成真实的图片。

`lqip` 这个工具可以将真实的图片虚化，转换为很小的base64编码。这样我们可以先使用base64加载虚化的图片。

```javascript
const lqip = require('lqip');
const file = './in.png';
// image
lqip,base64(file).then(res => {
    console.log(res); // 输出base64
})
// color
lqip.paletter(file).then(res => {
    console.log(res); // 图片颜色值
})
```

也可以使用低质量图片占位符，通过 `sqip` 将图片进行转换，它是基于SVG的图像占位符实现的。

```javascript
const sqip = require('sqip');

const result = sqip({
    filename: './in.png',
    numberOfPrimitives: 10 // 效果值
});

console.log(result.final_svg); // 输出svg格式
```

相比 `lqip` 来说 `sqip` 效果会好很多，而且可以设置不同的大小。

#### 1.5 webfoot 代替图片

使用web font来代替图片，比如说小图标等业务小图片。

#### 1.6 DataUrl 的方式（base64）

用dataurl的方式，也就是前面的base64的方式来代替图片，这样用户就不需要发送http请求了。

#### 1.7 雪碧图

采用雪碧图将多个小图片合成一个大图，这样也会节省很多的图片请求。

#### 1.8 图片服务器自动优化

图片服务器优化是指可以在图片url连接上增加不同特殊参数，让服务器自动生成不同格式，大小，质量的图片。

比如说可以对图片做一些裁剪，裁剪成我们需要的图片，也可以支持不同格式的转换，比如说jpg，gif，png，webp等也可以设置图片的压缩比。

也可以对图片添加一些水印，高斯模糊，重心处理等还可以增加一些AI的能力，比如说用户上传的图片是否涉黄。还可以通过智能抠图，智能排版，智能配色智能合成等功能完善图片。



### 2. HTML 优化

#### 2.1 精简html 代码

可以减少html的嵌套也就是层级关系尽量减小，也可以减小DOM节点数也就是尽量压缩优化DOM的节点数, 让浏览器渲染的DOM节点数最少。

减少一些无语义的代码，比如说空标签清浮动那种代码`<div class="clear"></div>`能不用最好不要用。

删除链接中的http或者https，因为一般链接的协议头和页面的协议头都是一致的，写他们多了4-5个字符其实是没有什么意义的。而且可以减少代码体积。

也可以删除多余的空格，换行符，缩进和不必要的注释，一般会用压缩工具来处理这个过程。可以省略一些标签和属性。使用相对路径的url，最大范围的减少字节数。

#### 2.2 文件位置

css文件链接尽量放在页面头部，css加载不会阻塞DOM Tree解析，但是会阻塞DOM Tree渲染，也会阻塞后面js执行。也就是说DOM Tree在渲染前就要解析好CSS，从而减少浏览器重排文档的次数。而且css放在页面底部会导致页面白屏时间变长。

js文件一般放在页面底部，这是防止js的加载和解析阻塞页面元素的正常渲染。

#### 2.3 用户体验

设置favicon.ico, 如果不设置控制台会报错，而且用户访问的时候地址栏也是空的，不利于品牌记忆。

增加首屏必要的css和js，一般页面需要在等待所有的依赖加载完成才会展示，这样就会导致页面存在空白。影响用户体验，可以增加背景图或者loading或者骨架屏，比空白页好很多。



### 3. CSS 优化

#### 3.1 提升 CSS 渲染性能

谨慎使用一些expensive的属性，比如nth-child伪类或者position:fixed定位，因为这些比较消耗浏览器的渲染性能。

尽量减少一些样式层级的级数，比如，div ul li span i { color: red}, 其实我们可以给i标签设置class，直接书写样式。

避免使用占用过多cpu和内存的属性，比如text-indent不要设置太大的值。

尽量避免使用耗电量大的属性，比较占用GPU, 比如transfrom是，transitions, opacity.

合适的使用css选择器, 尽量避免使用通配符，避免使用css表达式。`color: expression((new Date()).getHours() % 2 ? "#fff" : "#000")`。

避免类正则的属性选择器。*=， |=， ^=, $=，使用外链的css，可以单独形成文件放在cdn，使用缓存形式加载。避免使用@import因为他的加载会阻塞进程，需要加载完毕才会向下执行。

精简css代码，使用缩写的语句，比如margin-top可以写在margin中，再者如果值为0能删除就删除，删除不必要的单位值，删除过多的分号，删除空格和注释。尽量减小样式表的体积。其实这些都可以使用压缩工具来处理，会方便很多。

#### 3.2 合理使用web fonts

可以将字体文件部署到cdn上，加快用户端的加载速度，也可以将字体以base64的形式保存在css中，并通过localStorage进行缓存。一些谷歌字体库应该使用国内托管服务不要直接使用源地址。

#### 3.3 css动画优化

避免同时动画，也就是说用户访问的屏幕区间里面不要有过多的动画，动画太多会干扰用户正常浏览网站，而且动画多也影响浏览器的性能。

延迟动画的初始化，可以让其它css先渲染，让动画延迟，比如说0.5或1。

可以借助svg去展示动画，样式放在css里面控制。



### 4. JavaScript 优化

#### 4.1 提升js文件的加载性能

这个基本每个人都知道，就是css文件放在head标签中，js文件放在body结尾的地方。这个是js的加载不要影响html的渲染。

#### 4.2 变量和函数方面的优化

尽量使用id选择器，因为id选择器在查询效果上效率最快。

避免使用eval，这个方法比较消耗能行。

js函数尽可能保持简洁，不要把太多内容写在一个函数中。也建议使用事件的节流函数。事件委托等等。

#### 4.3 js动画

尽量避免添加大量的js动画，css3动画和canvas动画都比js动画性能好。

使用requestAnimationFrame来代替setTimeout和setInterval，因为requestAnimationFrame可以在正确的时间进行渲染，setTimout和setInterval无法保证渲染时机。不要在定时器里面绑定事件。

#### 4.4 使用逻辑缓存

缓存dom对象，也就是用一个变量来存储dom对象，不要每次使用都查询。

缓存列表长度，也就是说用变量存储dom元素的个数，而不是每次都重新计算。

比如百度M站，会把页面的css和js放在本地存储里面，这样后面再加载的时候就直接从本地存储里面取，实现秒考的效果。不过本地存储空间有限，要谨慎使用。



### 5. 减少页面回流和重绘

1. **css**

避免过多的样式嵌套，最好可以快速的定位到元素。

避免使用css表达式，css表达式会在css绘制的过程中都会执行，会增加重排和回流的次数。

可以使用绝对定位让动画元素脱离文档流。

避免使用table布局他会引起浏览器的多次重绘，也不要使用float布局。

图片最好设置好设置width和height，这样图片在加载之后布局就可以确定了。

简化浏览器不必要额任务，使用viewport设置屏幕缩放级别。

避免频繁设置样式，将多个样式操作合并修改,一次性的更新。

2. **js**

为了减少回流发生次数，应该避免频繁操作DOM，可以合并多次对DOM的修改，一次性批量处理。

控制绘制过程和绘制区域，绘制过程开销比较大的属性设置应当避免使用。



### 6. 简化DOM操作

众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量DOM元素，想想一下，从一个上万节点的DOM树上，使用querySelectorAll或getElementByTagName方法查找某一个节点，是非常耗时的，另外元素绑定事件时，事件冒泡和事件捕获的执行也会相对耗时。所以一般我们应该合理的不熟业务逻辑，DOM节点过多时应该延迟即将呈现的DOM内容。

对DOM的操作最好统一处理后再统一插入到DOM Tree中。可以使用fragment对DOM和样式设置好再统一放到页面中去。

目前比较流行的框架，比如Angular，React和Vue都是使用虚拟DOM技术，通过diff算法简化和减少DOM操作。



### 7. 浏览器渲染过程

首先浏览器会解析HTML生成DOM Tree，然后解析CSS生成CSSOM Tree。接着JS会通过DOM Api和 CSSOM Api来操作DOM Tree和CSS Rule Tree 将DOM Tree 和 CSSOM Tree合成一颗渲染树Render Tree。

根据生成的渲染树进行回流，以计算每个节点的几何信息，包括位置，大小，样式等等。然后根据渲染树和回流得到的几何信息，得到每个节点上的绝对像素。

最后将像素发送给图片处理器也就是GPU进行页面展示。

前端页面渲染可以分为服务端渲染和客户端渲染。服务端渲染有传统的后端同步渲染，同构直出比如php，java, .net或者大家熟悉的node。

客户端渲染也就是js渲染，前后端分离，单页面应用。react, vue, ios,安卓，hybird app，flutter等。



### 8. 懒加载，预加载，预渲染

**懒加载**也叫**延迟加载**，指的是长网页中延迟加载特定元素，可以是图片也可以是js和css。懒加载的好处是可以减少当前屏无效资源的加载。

一般我们会把img标签的src属性设置为空字符串，真实的图片地址放在data-lazy中，当页面scroll到对应的位置时再通过DOM操作将src的值替换为data-lazy的值。

**预加载**是让浏览器预先加载某些资源，同样也是图片，js或者css，这些资源是在将来才会被使用的。

简单来说就是讲所需要的资源提前加载到浏览器本地，后面在需要的时候可以直接从浏览器的缓存中获取，而不用再重新开始加载。好处是减少用户后续加载资源等待的时间。

可以使用new Image的方式也可以使用标签的方式preload，prefetch， preconnect

```html
<link rel="preload" href="src/style.css" />
<link rel="prefetc" href="src/image.png" />
<link rel="dns-prefetch" href="https://my.com" /> <!-- 提前将dns缓存-->
<link rel="preconnect" href="https://my.com" /> <!-- 提前加载需要的资源 -->
```

另一种预加载组件的方式就是提前渲染它，在页面中渲染组件，但是并不在页面中展示，也就是渲染好后先隐藏起来，用的时候再直接展示。可以使用prerender将https://my.com页面先提前渲染好。

```javascript
<link rel="prerender" href="https://my.com" />
```



### 9. 接口服务调用优化

- 接口合并，指一个页面的众多的业务接口和依赖的第三方接口统一使用一个部署在集群的接口统一调用，以减少页面接口请求数。

- 接口上CDN，主要基于接口性能考虑，我们可以把不需要实时更新的接口同步至CDN，接口内容变更自动同步CDN。

- 接口域名上CDN可以增强可用性和稳定性。

- 接口降级，这个基于大促备战考虑，核心进行降级用基础接口进行业务实现，比如千人千面的推荐接口，在大促时间点可以直接运营编辑的数据，另外接口万一无法访问，使用预设好的垫底备份数据。

- 接口监控，监控接口的成功率不是常说的服务器TP99，而是和用户实际情况一直的成功和失败监控，比如弱网，超时，网络异常，网络切换等情况。排查出来问题需要联合后端，运维，网络岗位人员一并解决。



### 10. CDN

CDN是内容分发网络，利用每一台最靠近用户的服务器，更快更可靠的将文件发送给用户。以加快访问速度。

CDN的有点很明显，因为会给用户指派较近，较顺畅的服务器节点，所以速度会比较快，服务器放在不同地点，减少了互联的流量，也降低了快带成本，当某个服务器故障时，自动调用临近地区的服务器。

回源是指浏览器访问CDN上静态文件时，文件缓存过期，直接穿透CDN而访问源站机器的行为。这是CDN的一个策略。

CDN的缓存分为三级，浏览器本地缓存也就是header头配置的缓存，CDN边缘节点缓存，CDN源站缓，一般是三级，也可能业务比较少就采用两级缓存，浏览器缓存和CDN源站缓存。

缓存时间设置过短的话，CDN边缘节点缓存经常失效，导致频繁回源，增大了源站负载，访问速度也会变慢，缓存时间设置的过长，文件更新慢，用户本地缓存不能及时更新，所以一般是结合业务情况而定。

一般不同资源类型缓存时间设置不用，html一般3分钟左右，js，css可以10分钟，一天，一个月，看变更情况。

现在一般我们文件的命名都会以hash串的形式，如果文件有变更生成的文件名就会有变更，否则还是之前的名字，这样我们缓存的时间就可以设置的长一些。

CDN可以灰度发布，也就是在部分地区部分运营商优先发布静态资源，验证通过后再进行全量发布。具体实施可以从域名方面下手，设置特殊VIP解析到要灰度的城市或者运行商。也可以调整源站机器，给灰度的城市或者运营商配置单独的源站机器。

一般在活动期间比如说大促，需要增加机房宽带，增加运营商流量，增大CDN缓存时间等等。



### 11. DNS

DNS是将网站域名和地址互相映射的一个分布式数据库，我们访问一个网站首先会通过DNS将域名匹配为ip地址，然后再通过ip地址去访问对应的服务器。

客户端里面有一个http dns, 客户端直接访问http的接口，可以获取业务在域名访问系统中配置的最优ip，基于容灾的考虑，app内是需要保留使用运营商DNS解析方式的，客户端再获取到ip后会直接向ip中发送业务请求。

比如一个http请求，在header中会指定host字段，向ip发送标准的http请求就可以了，总的来说采用http-dns来解析域名能绕过三四级运营商接续域名出现的一些问题，在http-dns返回的正确ip之后是直接使用ip去发送http请求的，只需要关注通信内容的安全就可以了。

安卓系统可以采用okhttp模块，他支持http2,http2可以在一个链接上一次性发送多个请求，支持gzip，也支持响应缓存避免网络重复请求，如果服务器配置了多个ip地址，当第一个ip链接失败的时候，okhttp会自动尝试下一个ip地址。

ios没有现成的模块，我们可以在app启动时，缓存所有可能要用到的域名ip比如接口，网关，同时异步处理，客户端无需得到缓存结果。如果cache中有此域名的圆环，直接返回缓存的ip，如果缓存中没有此域名，则重新向httpdns server进行申请然后缓存下来。

H5的做法一般是设置多个域名，因为浏览器对并发数是有限制的，一个域名一般最大连接数是6，所以我们可以将用户访问的一些api接口作为一个域名，页面中的样式和资源可以设置成一个域名，图片也可以单独设置成一个域名，甚至多个域名，来打破浏览器的这种限制。



### 12. http优化

http的优化主要就是减少请求数，这可能是我们日常工作中经常遇到的，也是大家耳熟能详的。

图片可以使用雪碧图，dataurl, webfont。

可以考虑将业务中的js或者css合并，不要切割的太小。如果不想合并成一个可以使用Combo的方式让服务去返回，可以在url上通过参数的形式告诉服务加载那些资源。

接口也可以合并，不要拆分的太细，可以让服务去合并，不经常变化的接口和资源也可以存储在LocalSrorage，有变化就更新，没有变化就从本地取。

有些时候我们的某个页面会出现问题，或者打开白屏，但是接口没有问题，页面也没有问题，资源也是可以访问通的，这个时候可能就是cookie太大了，已经超出了原本可控的范围，我们都知道cookie是会随着页面间的跳转携带的，这就肯能导致页面无法访问，这种问题不常见，但实际工作中确实会遇到。

可以在页面中设置cookie白名单，意思就是定期检查我们的cookie，如果是需要的就保留，不需要的就删除，定期整理。cookie控制可以减小页面间传输的大小，也可以对cookie进行有效的管理。



### 13. 服务器缓存配置

当一个文件被浏览器加载的时候我们实际上是不知道这个文件是否是过期的，所以浏览器和服务器之间存在一种约定，通过header头的配置，确定文件是否过期。

一般在响应头中包含一个expires的头信息，他的值为日期+时间，表示在此时间之后，响应过期，如果数值为0，表示资源已经过期。

当然如果响应头中包含Cache-Control, 设置了max-age或者s-max-age指令，那么就会忽略expires，而取Cache-Control。

Cache-Control通过制定的指令来实现缓存机制，缓存指令是单向的，这意味着在请求中设置的指令不一定被包含在响应中。他的语法比较简单，Cache-Control: max-age=秒设置缓存存储的最大周期，超过这个时间缓存被认为过期。

ETag是资源版本的标识符，可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应，如果发生了改变，使用ETag有助于防止资源的同时更新相互覆盖。

ETag类似于指纹，也可能被某些服务器用于跟踪，比较ETag能快速确定资源是否变更，但也可能被跟踪服务器永久存留。
Last-Modified是一个响应收不，其中资源包含源头服务器认定的资源做出修改的日期和时间。他常被用作一个验证器来判断接收到的或者存储的资源是否一致。由于精度比ETag要低，所以这是一个备用机制，包含有if-Modified-Since或If-Unmodified-Since首部的条件请求会使用这个字段。

Date是通用的首部，其中包含了报文创建的日期和时间。

Gzip压缩

可以对文本进行压缩，一般是html，css，js，对于非文本不会压缩，比如说图片资源，压缩比率可以达到50%-70%



### 14. http2

http2是http的第二版，简称h2或h2c，它采用二进制传输数据，多路复用，允许通过一个链接发起多个请求，所以一般使用h2雪碧图就没什么用了，他超出了浏览器限制最大连接数的局限，对header头进行压缩从而降低传输体积，支持服务端推送(server push)，可以从服务端将数据推送给客户端。

开启HTTP2可以降低服务器压力，提升网站访问速度，而且可以更好的保护网站安全因为他是强制使用https的。

开启http2其实也很简单，我们需要重新编译nginx，并且开启http_ssl_module和http_v2_module
