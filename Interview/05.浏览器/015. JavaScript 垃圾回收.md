## JavaScript 垃圾回收方法

**垃圾回收 - GC（Garbage Collection）**

[垃圾回收](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。

程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。这个时候，不仅自己的程序无法正常运行，连其他程序也会受到影响。

需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，JavaScript 中依旧会出现内存溢出的情况。



**垃圾回收基于两个原理**

- 考虑某个变量或对象在未来的程序运行中将不会被访问
- 向这些对象要求归还内存



**垃圾回收方法**

JavaScript 中找到不再使用的内存主要有两种方式：**引用计数**和**标记清除**。

1. **引用计数（reference counting）**

​		在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将 “对象是否不再需要” 简化成 “对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。

```javascript
let obj1 = { a: 1 }; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 
let obj2 = obj1; // A 的引用个数变为 2

obj1 = 0; // A 的引用个数变为 1
obj2 = 0; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了
```

​		但是引用计数有个最大的问题： ***循环引用***。如下当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。

```javascript
function func() {
  let obj1 = {};
  let obj2 = {};

  obj1.a = obj2; // obj1 引用 obj2
  obj2.a = obj1; // obj2 引用 obj1
}
```

​		要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为 null。

```JavaScript
obj1 = null;
obj2 = null;
```



2. **标记-清除（mark and sweep）**

​		JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象...对这些活着的对象进行标记，这是**标记阶段**。**清除阶段**就是清除那些没有被标记的对象。

![标记清除](./images/mark-sweep.png)

​		**标记-清除**法是 JavaScript 中最常见的垃圾回收方式。为什么说这是种最常见的方法，因为从 2012 年起，所有现代浏览器都使用了标记-清除的垃圾回收方法，除了低版本 IE 采用的是引用计数方法。

​		标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。

​		标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。

![标记清除](./images/mark-sweep1.png)

​		**标记整理（Mark-Compact）算法** 可以有效地解决内存碎片的问题，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）

![标记整理](./images/mark-compact.png)