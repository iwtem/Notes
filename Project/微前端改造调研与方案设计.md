# 微前端改造方案设计

## 1. 需求背景

DM Hub 2.10 新发布了「智能员工任务」模块，部分私有化部署的客户希望这个功能能够部署到他们对应的版本（例如 2.7）中，由于 DM Hub 前端是整体打包的方式，无法针对某一功能模块进行单独的发布部署。而当前解决这个问题的唯一办法就是通过代码迁移的方式，将代码回迁到 2.7 版本中，并且通过开放平台配置，应用市场插件的形式加载。但是这样会出现维护两套代码的问题，后续客户要升级到更新的版本，仍然需要重新走一遍代码迁移的流程。另外一点就是客户会提出疑问，购买的模块为何变成了插件，而不是系统本身的功能。

所以 DM Hub 亟需一套架构体系，能统一管理不同团队业务线，可以将一个复杂的单体应用以功能或业务需求垂直的切分成更小的子系统，满足模块的独立开发、部署、交付的需求，更容易的集成其他版本功能或其他系统。具体需求如下：

- 各个模块可以进行增量升级
- 模块之间需求迭代互不阻塞
- 支持配置并动态集成不同版本的模块
- 支持加载第三方应用，包括 JS、HTML 类型的资源入口
- 用户体验上整个系统是单一产品
- 基础库在开发及运行时可以共享
- 模块需要具备缓存 (keep-alive) 能力，应用切换状态不能丢失
- 提供统一的登录会话管理、租户组织切换、插件管理、权限管理、菜单管理、路由管理、主题管理、国际化管理等
- 提供全局的状态管理、模块间的通信能力等

## 2. 架构分析

微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、部署、交付的应用，而在用户看来仍然是内聚的单个产品。DM Hub UI 本身是单页面应用结构，所以基于 `基座管理` + `子应用分治` 的微前端方案是一种比较自然的选择。TMS 中注册子应用，DM Hub 运行时基座将会获取注册的子应用列表信息，再通过基座来动态控制子应用的渲染和销毁，并提供集中式的模式来完成应用间的通信和应用的公共依赖管理。

![DM Hub](./images/dmhub-micro.png)

通过基座管理可以将不同的应用聚合起来，它可以给带来以下优势：

- **统一管理子应用。**管理各个应用的加载与运行。
- **开发者可以更专注于业务的开发**。基座会提供配套的登录会话管理、权限管理、菜单管理、路由管理、主题管理等，子应用只需关心业务功能本身的开发。
- **更容易地集成应用**。不管是自己的业务应用、老旧系统、还是外部第三方应用，都可以在极少改动的情况下集成进来。
- **拆分巨石应用，让子应用可以按照“业务聚合”**。让应用更轻量、内聚、更可维护。

![image](./images/micro-basic.png)

TMS 系统提供应用的管理（菜单配置），根据不同用户的需求配置展示对用的应用列表。当 DM Hub UI 基座加载后会获取到应用配置，包括 **应用分组信息**、**子应用名称**、**子应用路由**、**子应用资源路径**（微应用入口文件地址，后续可能是通过版本列表选择对应的文件地址）等，基座会把这些菜单展示到 DM Hub UI 菜单列表中。当点击某一菜单后，基座会监听当前路由的变化，然后开始请求对应子应用的资源路径并进行加载渲染。

![DM Hub UI 架构](./images/dmhub-micro-arch.png)

以上架构是从 `开发规范` 到 `基础库` 、从 `管理系统` 到 `微前端基座` 、从 `开发调试` 到 `部署运维` 的一整套体系化的方案：

1. **基础库**，将每个应用都重复的工作提取出来，重新设计，并严格管理起来。使之能真正有效地服务业务开发，避免重复造轮子。
2. **开发规范**，提供更丰富的开发规范、指导、最佳实践。
3. **管理系统**，负责微应用的管理。
4. **基座** ，基座是微前端应用集成的一个重要平台，整个微前端的核心，负责管理微应用，并为微应用的开发提供必要的支撑。同时也肩负着管理公共资源、依赖的责任。
5. **微应用**，负责具体业务实现，按照业务聚合和拆分。
6. **运行容器** ，提供一套微前端的运行和部署方案。

## 3. 技术分析与选型

### 3.1 什么是微前端？

微前端这个名词，第一次被提出是在 2016 年年底，**指用来构建能够让多个团队独立交付项目代码的现代 web app 技术，策略以及实践方法**。从定义中可以看出，微前端不是一门具体的技术，而是整合了技术、策略和方法，可能会以脚手架、辅助插件和规范约束这种生态圈形式展示出来，是一种宏观上的**架构**。

现代的前端应用的发展趋势正在变得越来越富功能化，富交互化，也就是传说中的 SPA (单页面应用)；这样越来越复杂的单体前端应用，背后的后端应用则是数量庞大的微服务集群。前端项目，随着时间推进，会变得越来越庞大，越来越难以维护，这种应用也被称为**巨石单体应用**。

![Monolithic Frontends](./images/monolith-fe.png)

微前端概念将微服务这个被广泛应用于服务端的技术范式扩展到前端领域，它摒弃大型单体方式，将前端整体分解为小而简单的块，这些块可以**独立开发、测试和部署**，同时仍然聚合为一个产品出现在客户面前。可以理解微前端是一种将多个**可独立交付**的小型前端应用聚合为一个整体的架构风格。

微前端背后的思想是认为：现代复杂的web app或者网站，通常由很多 **相对独立的功能模块组合而成**，而对这些模块负责的应该是 **相互独立的多个团队**。这些独立的团队由于专业分工不同，会负责着 **特定的业务领域**，以及完成 **特定的开发任务**。这样的团队，通常在人员组成方面囊括了从前端开发到服务端开发，从 UI 实现到数据库设计这样 **端到端** 的 **跨职能人员** 构成。这也符合了我们的业务需求，和现有的开发模式基本符合。

![End-To-End Teams with Micro Frontends](./images/verticals-headline.png)

### 3.2 微前端的问题

微前端技术可以帮助我们很好的解决业务上的问题，但是同时也带来技术上的挑战，比如**样式冲突**、**脚本互斥**、**公共依赖加载**、**消息通信**等。

#### 3.2.1 样式冲突

由于在微前端场景下，不同技术栈的子应用会被集成到同一个运行时中，所以我们必须在框架层确保各个子主应用之间不会出现样式互相干扰的问题。例如：一个团队的微应用的样式表为 `h2 { color: black; }`，而另一个团队的微应用则为 `h2 { color: blue; }`，而这两个选择器都附加在同一页面上，就会冲突。

为了避免这个问题，常见的解决方案有：

- 严格的命名约定，例如 BEM；
- CSS Module；
- 各种 CSS-in-JS 库或原子库（Tailwind CSS）；

#### 3.2.2 脚本互斥

每当微应用的 JavaScript 被加载并运行时，它的核心实际上是对全局对象 Window 的修改以及一些全局事件的改变，例如 jQuery 这个 js 运行后，会在 Window 上挂载一个 window.$ 对象，对于其他库 React，Vue 也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响。

解决这个问题最普遍的做法是采用沙箱机制（SandBox），它可以很好的将全局变量进行隔离，并且允许多实例共存，同时要拥有一套安全策略，用于资源加载限制、LocalStorage 区分、Cookie 读写等。

**常见实现沙箱的方法：**

- 沙箱快照；
- ES6 的 Proxy 代理；

#### 3.2.3 公共依赖加载

如果多个微应用都使用了某个版本的依赖，比如 react、jquery 等，当加载这些子应用的时候就会出现依赖被重复下载加载的问题，这样会导致资源的浪费，甚至增加运行时的应用体积，可能会带来性能上的影响。

#### 3.2.4 消息通信

微前端最常见的问题之一是如何让微应用之间能够相互通信。一般而言，我们建议让微应用之间尽可能少地交流，因为这通常会重新引入我们最初试图避免的那种不适当的耦合代码。也就是说，通常我们只需要**某种程度的跨应用通信**即可。

**常见的通信方式：**

- 使用 `自定义事件通信`，是降低耦合的一种好方法；
- 可以考虑 React 或 Vue 应用中常见的 `全局 state store 机制`；
- `发布-订阅（pub/sub）模式`的通信机制；
- 使用 `地址栏`作为通信机制；

### 3.3 微前端框架

为了解决以上问题，微前端框架就因为这些问题运用而生了。

#### 3.3.1 Single-SPA

[single-spa](https://single-spa.js.org/) 是最早的微前端框架，兼容多种前端技术栈， 是一个将多个单页面应用聚合为一个整体应用的 JavaScript 微前端框架。

single-spa 会在基座应用中注册所有子应用的路由，基座保存各子应用的路由映射关系，充当微前端控制器Controler，当 URL 匹配子应用的路由时激活并挂载子应用，或者当子应用不处于激活状态时，将子应用从页面中移除卸载。

**优点**

- 敏捷性 - 独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新；
- 技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权；
- 增量升级，在面对各种复杂场景时，通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略；
- 更快交付客户价值，有助于持续集成、持续部署以及持续交付；
- 维护和 bugfix 非常简单，每个团队都熟悉所维护特定的区域；

**缺点**

- 无通信机制
- 不支持 Javascript 沙箱
- 样式冲突
- 无法预加载

[点击在线体验](https://single-spa.surge.sh/)

#### 3.3.2 Qiankun

[Qiankun](https://qiankun.umijs.org/zh) 是一个基于 single-spa ，阿里系开源的微前端框架，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。

**设计理念：**

- `由于主应用微应用都能做到技术栈无关`，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。
- 同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入 `像使用 iframe 一样简单`。
- 微前端的核心目标是 `将巨石应用` 拆解成若干可以 `自治的松耦合微应用`，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 `独立开发、独立运行` 的能力。

**优点**

- 📦 基于 single-spa 封装，提供了更加开箱即用的 API。
- 📱 **技术栈无关**，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。
- 💪 **HTML Entry 接入方式**，让你接入微应用像使用 iframe 一样简单。
- 🛡 **样式隔离**，确保微应用之间样式互相不干扰。
- 🧳 **JS 沙箱**，确保微应用之间 全局变量/事件 不冲突。
- ⚡️ **资源预加载**，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。
- 🔌 **umi 插件**，提供了 [@umijs/plugin-qiankun](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fplugin-qiankun) 供 umi 应用一键切换成微前端架构系统。
- 🔥 **社区较为活跃**，维护者也较多，有问题会及时得到响应；

**缺点**

- 可能对一些 jQuery 老项目支持性不是特别好；
- 安全和性能可能会有影响，具体取决于项目；
- 对 eval 的争议，`eval`函数的安全和性能有一些争议；

#### 3.3.3 Micro App

[Micro App](https://micro-zoe.github.io/micro-app/) 是京东出的一款基于 `Web Component` 原生组件进行渲染的微前端框架，不同于目前流行的开源框架，它从组件化的思维实现微前端，旨在降低上手难度、提升工作效率。

它是目前市面上接入微前端成本最低的框架，并且提供了 **JS沙箱**、**样式隔离**、**元素隔离**、**预加载**、**资源地址补全**、**插件系统**、**数据通信** 等一系列完善的功能。Qiankun 微前端框架的优势他都有，并且零依赖。

![image](./images/micro-app.png)

[点击线上体验](http://www.micro-zoe.com/main-vue2/)

#### 3.3.4 Garfish

[Garfish](https://www.garfishjs.org/) 是由字节跳动开源的一套微前端解决方案，主要用于解决现代 web 应用在前端生态繁荣和 web 应用日益复杂化两大背景下带来的 `跨团队协作、技术体系多样化、应用日益复杂化`等问题，Garfish 已经经过大量的线上应用的打磨和测试，功能稳定可靠。

**框架特性**

- 🌈 **丰富高效的产品特征**
  - Garfish 微前端子应用支持任意多种框架、技术体系接入
  - Garfish 微前端子应用支持「**独立开发**」、「**独立测试**」、「**独立部署**」
  - 强大的预加载能力，自动记录用户应用加载习惯增加加载权重，应用切换时间极大缩短
  - 支持依赖共享，极大程度的降低整体的包体积，减少依赖的重复加载
  - 内置数据收集，有效的感知到应用在运行期间的状态
  - 支持多实例能力，可在页面中同时运行多个子应用提升了业务的拆分力度
- 📦 **高扩展性的核心模块**
  - 通过 Loader 核心模块支持 HTML entry、JS entry 的支持，接入微前端应用简单易用
  - Router 模块提供了路由驱动、主子路由隔离，用户仅需要配置路由表应用即可完成自主的渲染和销毁，无需关心内部逻辑
  - Sandbox 模块为应用的 Runtime 提供运行时隔离能力，能有效隔离 JS、Style 对应用的副作用影响
  - Store 提供了一套简单的通信数据交换机制
- 🎯 **高度可扩展的插件机制**
  - 提供业务插件满足各种定制需求

#### 3.3.5 Bit

由国外 [bit](https://bit.dev/) 开发团队开源的一款跨项目的组件复用平台框架；将独立的组件构建、集成组合到一起去管理；

**优点：**

- 具有传统单体式前端的安全性和健壮性；
- 介接入方式简单、可伸缩性强；
- 通过 简单的解耦代码库、自治团队、小型定义良好的 API、独立的发布管道 和 持续增量升级，增强工作流程；

严格意义上来讲 Bit 与微前端有较大的的出入，所以 Bit 较为适合那种使用组件来开发项目，且技术栈较为统一的项目。

#### 3.3.6 Module Federation

Module Federation 是 Webpack5 提出的概念，Module Federation 用来解决多个应用之间代码共享的问题，更加优雅的实现跨应用的代码共享。

MF 想做的事和微前端想解决的问题是类似的，把一个应用进行拆分成多个应用，每个应用可独立开发，独立部署，一个应用可以动态加载并运行另一个应用的代码，并实现应用之间的依赖共享。

### 3.4 技术分析

DM Hub 经过数年的产品迭代，到目前为止公有云已经发布到 2.10 版本，同时正在进行 2.11 产品的开发，此次方案的设计也是为 2.11 版本的开发与发布做准备。

#### 3.4.1 版本变革

**2.5** 版本及之前，DM Hub 应用市场仅支持 **.html** 形式的插件，并且插件只能通过新标签页的形式打开，相当于在前端只是提供了一个入口。

**2.6** 版本，DM Hub UI 将 `react-router-dom` 升级到了 6.0 版本，将原有的 MPA 改成了 **SPA**，同时支持了 **Webpack Module Federation**（简称 MF） 功能，插件可以额外支持以 **.js** 格式的文件，这种方式的好处在于插件嵌入在 DM Hub 产品的上下文中，从用户体验上无论是插件还是产品模块都是内聚的单一产品。

**2.8** 版本，DM Hub UI 将原有的 multirepo 代码管理模式重构成了 **monorepo** 的形式，将各个功能模块与基础库进行了细致的划分，同时统一基础库和功能模块的代码风格与标准、依赖与版本管理。

#### 3.4.2 框架分析

> **概念介绍**
>
> 1. **预加载**，指在应用尚未渲染时提前加载资源并缓存，从而提升首屏渲染速度。预加载不是同步执行的，它会在浏览器空闲时间，依照开发者传入的顺序，依次加载每个应用的静态资源，以确保不会影响基座应用的性能。
> 2. **通信机制**，指的是基座应用和子应用之间的数据传输与应用之间的数据通信。
> 3. **JS 沙箱**，相对纯净的运行空间，防止对 window 的访问和修改，避免全局变量污染。
> 4. **样式隔离**，应用与应用之间的样式不会被相互影响。
> 5. **元素隔离**，应用之间的元素可以重复，但是不会互相影响。比如两个应用都有 id=root 的元素，但是通过 document.getElementById 方法只会获取到当前应用中的元素。（ShadowDom）
> 6. **资源路径自动补全**，指对子应用相对地址的资源路径进行补全，以确保所有资源正常加载，如：子应用中引用图片`/myapp/test.png`，在最终渲染时会补全为子应用的域名+ 路径：`http://localhost:8080/myapp/test.png`。
> 7. **资源共享**，当多个子应用拥有相同的 js 或 css 资源，可以指定这些资源在多个子应用之间共享，在子应用加载时直接从缓存中提取数据，从而提高渲染效率和性能。
> 8. **Keep-alive**，在应用之间切换时，有时需要保留这些应用的状态，以便恢复用户的操作行为和提升重复渲染的性能，比如筛选条件。

本次改造的总体目标是 **基于微前端的 SPA 架构**，当前 DM Hub 已经是单页面应用，其本身已经有部分功能实现了微前端的功能，比如应用市场和自动流插件就是实现的以 MF 为微前端框架的架构。

从现状分析来看，DM Hub 本身已经在使用 MF 框架，实现以 MF 为微前端框架相对合理一些，但是 MF 也存在很多缺点，比如：

- 不支持路由管理
- 不支持基座与应用或应用与应用之间的通信管理
- 不支持 HTML Entry 接入方式
- 存在样式冲突与脚本互斥
- 与 Webpack 打包工具深度绑定在一起

下面是现在比较流行的几款开源微前端框架，从多个角度对这几个框架进行了以下对比：

|                   | Single-spa | qiankun          | Micro app              | Garfish          | Bit              | MF         |
| ----------------- | ---------- | ---------------- | ---------------------- | ---------------- | ---------------- | ---------- |
| 框架体积 Minified | 21.1 KB    | 114.7 KB         | 53 KB                  | 135.1 KB         | 2.4 MB           | -          |
| 发布时间          | 2015.9     | 2019.5           | 2021.7                 | 2020.12          | 2017.6           | -          |
| 最后更新时间      | 2023.6     | 2023.7           | 2023.5                 | 2023.6           | 2023.7           | -          |
| Release 版本数量  | 132 个     | 153 个           | 53 个                  | 327 个           | 68 个            | -          |
| GitHub Star 数量  | 12.5 K     | 14.6 K           | 4.4 K                  | 2.1 K            | 16.8 K           | -          |
| NPM 周下载数量    | 151,440    | 21,525           | 1,190                  | 1,828            | 3,634            | -          |
| Issues 数量       | 64 个      | 341 个           | 332 个                 | 7 个             | 86 个            | 22 个      |
| 通信机制          | 自定义事件 | Props + 全局变量 | PostMessage + 全局变量 | Props + 全局变量 | Props + 全局变量 | -          |
| 接入成本          | 高，改造多 | 中，改造适中     | 低，改造少             | 低，改造少       | 高，改造多       | 高，改造多 |
| JS 沙箱           | ❌          | ✅ Proxy          | ✅ Proxy                | ✅ Proxy          | ❌                | ❌          |
| 样式隔离          | ❌          | ✅                | ✅                      | ✅                | ❌                | ❌          |
| 预加载            | ✅          | ✅                | ✅                      | ✅                | ✅                | ✅          |
| 静态资源地址补全  | ❌          | ✅                | ✅                      | ✅                | ❌                | ❌          |
| Keep-alive        | ❌          | ✅                | ✅                      | ✅                | ❌                | ❌          |
| 支持 React        | ✅          | ✅                | ✅                      | ✅                | ✅                | ✅          |
| 结论              | 不考虑     | 待考虑           | 待考虑                 | 不考虑           | 不考虑           | 待考虑     |

选择框架的考量点主要包括：

1. **业务契合度**：是否能够满足业务需求

   - 2.11 及以后版本，产品本身支持了微前端的能力，满足该微前端框架的使用规则即可。

   - 2.6 - 2.10 版本，需要在开放平台配置，通过应用市场加载。应用市场支持 JSEntry、HtmlEntry 两种模式。对于 JSEntry，是通过 MF 加载，所以 **MF** 在这几个版本中是兼容的。对于 HtmlEntry，需要应用自身添加菜单栏和导航栏，理论上微前端框架根据当前是否是微前端环境判断都是可以支持。
   - 2.5 及之前版本，仅支持 HtmlEntry 模式。

2. **框架能力是否全面**

   对比 single-spa 和 bit，都是是国外开源较早的微前端框架，bit 严格来说不是微前端框架，微前端只是其能力的一部分，整体比较重，微前端的支持不是很全面。single-spa 是非常老牌的一个微前端框架，使用的人数很多，但是部分能力有点欠缺。而 qinkun 是基于 single-spa 开发的，完善了其能力，所以对于这两者 **qiankun** 是一个更好的选择。**micro-app** 和 **grafish** 在这方面也比较优秀。

3. **是否稳定维护、社区是否活跃**

   从社区活跃度来看，**single-spa**、**qiankun**、**bit** 都比较活跃，并且很多问题都很容易被检索解决，一直都处于稳定维护的状态。而 micro-app 和 garfish 使用的人都比较少，很多问题无法被解决。从 github 提出的 issues 来看，解决速度都比较慢，微信群的反馈也无人回应。

4. **文档资料，使用成本**

   从使用成本来看，**garfish** 和 **micro-app** 接入相对都比较简单。基本所有框架的文档资料都比较全。

从以上来看，qiankun 本身就是基于 single-spa 开发并且能力更全面、使用更简单，所以可以先把 ~~single-spa~~ 排除；~~bit~~ 体积太大，不是专门的微前端框架，所以也可以排除；其次是 ~~garfish~~，使用人数太少，坑可能比较多，也可以先排除掉。对于 micro-app，相对也不是很活跃，很有可能入坑，在与 qiankun 之间进行选择的话，更倾向于 qiankun 框架。另外，如果不考虑框架自身能力，MF 是最适合的选择。

综上所述，可以有以下几种选择：

- MF
- qiankun + MF
- micro app + MF

#### 3.4.3 发布方式

**应用跟随产品 release**，不需要单独控制子应用的版本，产品的版本即是应用的版本。比如产品当前的版本是 `2.11`，那么子应用的版本均是 `2.11`。如果部署到 `2.10` 版本中去，只需要构建出 `2.11` 版本应用的最新镜像再部署过去即可。

这里需要注意的是，如果应用依赖的版本在不同产品版本中存在不一致（比如 `2.11` 依赖了 React 18，`2.10` 使用的是 React 17），那么依赖不能进行共享，子应用需要单独把依赖打包进去加载。下面会单独对依赖共享进行介绍。

#### 3.4.4 基础库

如果一个基础库承载太多的功能，比如 `ui-common` ，可能会导致如下问题：

- 基础库的改动会影响所有依赖它的应用，即使改动的这个功能某些应用没有使用到（暂时只能通过依赖关系判断是否影响到某些模块，无法通过应用是否引用了基础库改动的功能判断，也可深入调研是否有解决方法）
- 功能过多管理比较杂乱，比如 api 管理、工具类、业务组件库，甚至存在从未使用的功能
- 子应用构建会先会构建依赖，功能过多会导致整体构建时间变长
- 增加子应用的打包体积（或者使用 Tree Shaking 解决）
- ...

所以应用通用功能提取、基础库的拆分、功能删减（未使用的功能，不通用的功能或者仅在某个应用中使用）、版本发布管理（语义化）也是非常有必要的一个环节。

#### 3.4.5 依赖共享

依赖的共享管理主要分为两部分：

- **公共依赖**，比如 react、moment，这些依赖的版本应该要统一，尽量避免不同的模块使用不同的版本，导致无法进行共享或者增加打包体积的问题。（当前大部分已经实现了版本统一，需要查缺补漏）。
- **基础库依赖**，同一 release 下，所有的基础库版本保持一致。

#### 3.4.6 CI/CD 

DM Hub 当前使用的是 Gitlab CI/CD 流程，如下图所示：

![Gitlab CI/CD](./images/dmhub-gitlab-cicd.png)

## 4. 方案设计

基于 [需求背景](# 1. 需求背景) 中的需求要点，方案设计主要涵盖三个层面：开发、构建部署、运行，具体包括如下要点：

1. **接入微前端框架，搭建基座应用**，实现微前端的能力，同时需要解决应用之间依赖共享的问题，支持 JS、HTML 文件的打包形式，兼容到 2.6 之前的版本。
2. **搭建子应用**，包括路由、Provider、跨域等配置；
3. **统一管理应用配置**，主要包括 webpack、dev-server、babel、tsconfig 等配置，另外区分本地与线上环境管理不同的域名
4. **划分基础库**，将庞大的基础库按照不同能力进行划分，包括组件库（根据情况再拆分）、工具库、国际化、API 库、脚手架、配置库
5. **构建流程调整**，微应用需要独立构建部署，生成独立的镜像。同时支持仅对变动的模块进行增量的构建部署，即同一仓库不同的目录，拥有独立的 Pipeline。另外还需要对 nginx、docker 等进行调整。
6. **TMS 调整**，TMS 菜单配置新增*菜单资源路径*，用于加载对应的微应用。

![Micro-Pipeline](./images/micro-pipeline.png)

下面的方案均是基于 **Task -「智能员工任务」**模块为子应用的设计。

### 4.1 搭建基座应用

根据之前 monorepo 模块的划分，apps/* 下单独的目录后续均可作为子应用。其中 **apps/main** 作为基座应用，需要包含以下功能：

- 登录会话管理、租户组织管理、用户及权限管理、主题管理 ✅
- 子应用管理、国际化管理、路由管理、权限管理、菜单管理、通信管理 ⚠️

同时包含以下模块，可以根据具体的需求拆分为子应用：

- 首页、应用市场、系统设置、邀请、导航、搜索、审批、通知、任务分配、操作日志

#### 4.1.1 接入微前端框架

`Micro App` 框架只需要在基座应用配置，子应用按照约定接入即可，所以此处的调整是在 **apps/main** 中调整。

1. **安装 `micrp-app`**

   在 apps/main 的 workspace 安装即可。

   ```bash
   yarn workspace @dmhub-ui/main add @micro-zoe/micro-app
   ```

2. **引入 `micro-app`**

   在 apps/main/src/bootstrap.js 中引入，代码如下：

   ```javascript
   import microApp from '@micro-zoe/micro-app';
   
   // 文件底部添加
   microApp.start();
   ```

   其中 start 是微前端框架的注册函数，全局只会执行一次，具体传参参考：[官方 API](https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/api)

3. **分配一个路由给子应用**

   以「智能员工任务」为例，移除该模块现有路由配置，替换为下面的代码：

   ```diff
   const defaultRouteConfig = [
   - ...taskRoute,
   + {
   + 	path: '/task',
   +   component: () => {
   +			return <micro-app name='task' url='http://localhost:9000/' baseroute='/task' />;
   + 	}
   + }
   ];
   ```

#### 4.1.2 国际化调整

由于每个子应用有独立的打包构建策略，其本身与主应用不在同一个上下文环境中，所以相关的 Provider 与配置需要独立提供，为了不让每个应用重新写一遍相关的配置，所以需要把重复的部分抽取出来，这里会将「国际化」相关的配置独立出为一个基础库，提供给其他模块/库使用，放在 **packages/i18n** 中，主要包括以下功能：

- 提供国际化脚本，比如提取、编译、替换等功能
- 提供国际化的 Provider
- 提供切换语言/当前语言的 hooks 或方法

基座承担的国际化功能主要就是用于切换语言。

#### 4.1.3 菜单、路由、权限增强

**当前菜单配置策略**：先在代码中配置好路由，然后再将路径地址配置到 TMS 中，再由 DM Hub 获取到 TMS 的配置，加载到左侧菜单栏中，当点击某个菜单后，会加载该路径下的文件展示到右侧面板中。

**调整后的配置策略**：查询 TMS 菜单的配置并展示（后面会提到菜单如何调整），通过基座获取并加载对应的应用，应用的路由由其本身根据约定定制即可。

另外路由增加统一的拦截规则，如果没有对应的功能权限，统一跳转到 403 页面。

> 可能的影响：搜索、快捷新建

#### 4.1.4 通信管理

通信的方式主要有两种情况，基座与应用之间的通信，应用与应用之间的通信。

具体的使用方法参考：https://micro-zoe.github.io/micro-app/docs.html#/zh-cn/data

### 4.2 TMS 菜单配置调整

#### 4.2.1 新增应用地址 `path` 参数配置

基座加载子应用时，需要有三个必要的参数：

- **path，应用的资源地址**，即入口文件在服务器上的地址
- **name，应用的唯一标识**，这个字段可以使用现有菜单中的 id
- **activeRoute，激活应用的路由**，也是唯一的，根据路由去加载对应的应用资源

将链接更改为路由，增加应用地址配置 `path`，具体如下图：

![TMS-URL](./images/tms-url.png)

### 4.3 搭建子应用

#### 4.3.1 基础配置搭建

基础配置主要包括 webpack、babel、scripts、tsconfig 等（后续调整为公共配置进行引用）。

对于 webpack、babel、scripts 参考现有的 apps/main 中的配置，tsconfig 使用本身的即可，webpack 要实现多入口类型的打包策略。

另外需要注意的是在 `webpack-dev-server` 中添加 headers：

```json
{
  // 允许跨域
  headers: {
  	'Access-Control-Allow-Origin': '*',
	}
}
```

#### 4.3.2 调整入口文件

根据具体的微前端框架规则进行调整即可。

### 4.4 基础库划分与依赖共享

**巨无霸的公共依赖被太多的应用引用，会让升级和改动变得很困难。**比如某个依赖库被多个应用引用，然后对它进行了某个功能的调整，而且这个调整本身是对某些应用是没有影响的，但是由于它的改动就可能会导致所有依赖的应用均会被重新构建部署。所以让依赖进行更小颗粒度的划分，有利于后续更好的升级与维护。

当然每个子应用可以拥有依赖的独立版本，互不干扰。但是每个应用都会加载一遍依赖，这样就会造成资源的浪费与运行时的开销。所以我们应该尽可能让依赖版本统一，依赖的调整更小范围的影响到应用，同时对同一版本的依赖实现一次加载，多处使用。

应用的公共依赖版本的统一本身和微前端的理念相悖，所以我们在同一 Release 版本中，尽可能的保证依赖版本的统一，除非有特殊情况可以单独调整，这样可以更好的进行依赖的共享。

#### 4.4.1 统一公共依赖版本

当前 DM Hub 公共依赖库主要分为三类，基础组件库、产品组件库和开源库。

**基础组件库**本身服务于多种业务场景，会被多个产品比如 DataHub、AIHub 等引用。它的版本不会跟随某一产品的版本发布而发布新版本，完全是独立控制。针对这一类的组件库版本，保持各个应用所引用的版本统一即可，避免出现同一产品引用多个版本，增加打包体积与运行时开销。

- `@prism/ui-components`，UI 基础组件
- `@prism/ui-core`，UI 框架
- `@prism/icons`，图标库

**产品组件库**已经实现了 monorepo 代码管理，所以各个应用在同一 Release 下引用都是一致的，不存在版本的差异，所以无需考虑。

**开源库**主要就是当前 DM Hub 使用的技术栈，比如 `react`、`antd`、`moment`、`lodash`、`router` 等，另外还有一些被某一些模块引用的依赖库，使用频率也很高但并不是所有地方都会使用。针对这些依赖尽可能的保证依赖版本的统一，导致无法进行共享或者增加打包体积的问题，除非有特殊情况可以单独调整。当然当前大部分已经实现了版本统一，需要查缺补漏即可。

#### 4.4.2 基础库的调整与划分

DM Hub 的产品组件库由于经历了长时间的业务需求迭代、持续沉淀，但是由于缺少维护和整理，带来了以下问题：

- 部分组件库变得非常的庞大和臃肿，导致构建缓慢，也不利于子应用的升级与依赖共享
- 组件库的分工不够明细，功能过于复杂
- 组件库存在较多的组件未被使用或者仅使用一次，不适合放在组件库
- 组件库存在很多重复的组件，可能只是细节上的差别，可以合并在一起
- 缺少开发文档和测试用例，开发不知如何使用或者不知道组件的存在，组件长期无人维护

结合以上问题，一个好的组件库和组件应该需要满足 **复用性**、**易用性**、**合理性**。对现有的基础库的划分与调整，是更有利于组件库的长期维护与使用。

现有的 DM Hub 的组件库，主要如下：

1. **`ui-common`，业务组件库**

   组件库比较庞大，功能较多，包含一些工具函数、接口定义、业务组件，还有一些比较重型的组件，具体可以参考：https://confluence.xiaoshu.biz/pages/viewpage.action?pageId=133669614

2. **`uilib`，业务组件库**

   该组件库设计的初衷是避免和业务关联，现在看来已经和 ui-common 没什么区别，可以和 ui-common 一起重新设计

3. **`uilib-ana`，分析中心的组件**

   如果复用性不高，可以考虑迁移回分析中心

4. **`flow-editor`，自动流编辑器**

   现在仅供自动流程使用，没有无可复用性，可以迁移回自动流程

5. **`tsconfig`，TypeScript 共享配置**

   提供给各个模块与组件库使用的 TypeScript 配置

![dependencies-before](./images/dependencies-before.png)

根据基础库的功能进行划分，包括配置、多语言、工具库、接口、hooks 库、组件库及一些大型组件；根据业务的相关程度，如下图进行从下往上的划分，下层的组件只能被上层的组件所引用，不可出现下层组件引用上层组件。

![dependencies-new](./images/dependencies-new.png)

#### 4.4.3 依赖的共享

依赖的共享按照颗粒度的划分可分为**单一库级别共享**和**组件级别共享**。

#### 4.4.4 基础库版本管理

版本管理的主要目的是为了对依赖共享的更好处理。比如某个模块在 2.11 和 2.10 两个版本下对 ui-common 的依赖的代码肯定是不一致的，如果没有版本的区分是无法知道能否对该版本进行共享，可能会导致功能的缺失而报错。当前版本的管理并不意味着一定要进行 npm 包的发布，仅调整 package.json 的版本也可。

可以参考：https://github.com/changesets/changesets

### 4.5 构建部署

主要包括：Dockfile 调整、Ngnix 配置调整、Pipeline 调整、应用的增量构建部署等内容。

下面是 DM Hub UI 现在的构建部署策略：

![build-before](./images/build-before.png)

部署方式大概有以下两种方式：

1. **单个 nginx 容器**。分别编译好主应用和子应用，将主应用与子应用的构建产物部署到一个 nginx，放到对应的数据卷挂载目录，通过 `docker-compose` 启动。只使用一个 nginx 容器，通过监听不同端口，部署多个应用，再在主应用的端口里面添加对应路由代理到子应用。

2. **多个 nginx 容器。**分别构建主应用与子应用的 `docker` 镜像，只暴露主应用的端口，主应用去连通子应用，通过配置 `nginx` 转发规则，匹配访问路径子应用容器端口。

   具体来讲就是，一个微前端项目中包括一个**主应用**和数个**子应用**。把**主应用**和**子应用**都生成对应的`nginx`容器放在服务器里，在**主应用`nginx`容器**里配置路径规则转发获取**子应用**资源的请求。客户端发出路径前缀为`/microA/`的请求，则是请求 A 子应用的资源；发出前缀为`/microB/`的请求，则是请求 B 子应用的资源。这些请求都会由**主应用`nginx`容器**做反向代理处理。具体如下图：

   ![build-after](./images/build-after.png)

由于业务需求是需要把某个应用部署到产品的其他版本中去，而部署到老版本只能通过创建插件的方式，所以需要一个单独的 docker 镜像，单个 nginx 并不适用，所以选择方式二。

## 5. 遗留问题

1. ✅ 点击菜单会刷新整个页面及左侧菜单未被选中
2. webpack、babel 等相关配置需要有公共的配置，避免每个应用维护一套，另外需要优化配置
3. 路径前缀 /ui 及 public path 的问题解决
4. 依赖共享，版本管理
5. 基础库划分，开启 sideEffects: false，实现 tree sharking
6. ✅ 移除 ui-icons 的动态导入（打包出来的 chunks 文件太多）
7. CI/CD 流程优化，包括增量构建
8. ❎ TMS 菜单配置 + 后端接口
9. 编写其他模块接入微前端的开发文档
10. 版本兼容问题的考虑
11. 应用市场、自动流、主应用的三个地方的微应用的加载，进行统一
12. 支持 html 入口形式
13. 是否可以直接加载插件或者其他 shared 的组件
14. 国际化

## 6. 场景考虑

1. 是否能够兼容到旧版本的系统
2. 旧版本升级到最新版本有何影响
3. External 的依赖库是否有影响，或者如何更好的处理
4. 依赖共享如何处理

## 7. 注意事项

### 7.1 不同版本微应用的部署

2.10 及之前的版本，由于不支持微前端应用的能力，所以无法实现通过功能模块接入高版本模块，但是可以通过插件平台注册的方式引入高版本的模块。主要分为两类：

- 2.6 之前的版本，需要将微应用打包为 HTML 入口的形式。
- 2.6 到 2.10 版本，将微应用打包为 JS 入口的形式。

2.11 及之后的版本，不需要通过插件平台注册，可以通过 TMS 菜单配置的形式引入。

### 7.2 无法直接部署微应用的场景

1. 如果一个微应用的功能除了在自身中实现，同时在其他模块中也有实现，比如自动流程节点的形式，那么除了部署该微应用，同时需要部署其他应用；如果其他应用没有被改造为微应用，那么需要迁移这个应用的代码。
